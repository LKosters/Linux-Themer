"use client"

import { useMemo } from "react"
import { useHyprconf } from "./config-context"
import type { HyprconfConfig } from "./config-context"

export function generateHyprlandConf(config: HyprconfConfig): string {
  const lines: string[] = []

  lines.push("# Hyprland Configuration")
  lines.push("# Generated by Linux Themer")
  lines.push("")

  // Monitors
  lines.push("# Monitors")
  for (const m of config.monitors) {
    const name = m.name || ","
    lines.push(`monitor = ${name}, ${m.resolution}, ${m.position}, ${m.scale}`)
  }
  lines.push("")

  // Environment variables
  if (config.envVars.length > 0) {
    lines.push("# Environment Variables")
    for (const e of config.envVars) {
      lines.push(`env = ${e.key}, ${e.value}`)
    }
    lines.push("")
  }

  // Autostart
  if (config.execOnce.length > 0) {
    lines.push("# Autostart")
    for (const cmd of config.execOnce) {
      lines.push(`exec-once = ${cmd}`)
    }
    lines.push("")
  }

  // Input
  lines.push("input {")
  lines.push(`    kb_layout = ${config.kbLayout}`)
  if (config.kbVariant) lines.push(`    kb_variant = ${config.kbVariant}`)
  if (config.kbOptions) lines.push(`    kb_options = ${config.kbOptions}`)
  lines.push(`    follow_mouse = ${config.followMouse ? 1 : 0}`)
  lines.push(`    sensitivity = ${config.sensitivity}`)
  lines.push(`    repeat_rate = ${config.repeatRate}`)
  lines.push(`    repeat_delay = ${config.repeatDelay}`)
  lines.push(`    natural_scroll = ${config.naturalScroll}`)
  lines.push(`    accel_profile = ${config.mouseAccelProfile}`)
  lines.push("")
  lines.push("    touchpad {")
  lines.push(`        natural_scroll = ${config.touchpadNaturalScroll}`)
  lines.push(`        tap-to-click = ${config.touchpadTapToClick}`)
  lines.push(`        disable_while_typing = ${config.touchpadDisableWhileTyping}`)
  lines.push("    }")
  lines.push("}")
  lines.push("")

  // General
  lines.push("general {")
  lines.push(`    border_size = ${config.borderSize}`)
  lines.push(`    gaps_in = ${config.gapsIn}`)
  lines.push(`    gaps_out = ${config.gapsOut}`)
  lines.push(`    resize_on_border = ${config.resizeOnBorder}`)
  lines.push(`    allow_tearing = ${config.allowTearing}`)
  lines.push(`    layout = ${config.layout}`)
  lines.push("}")
  lines.push("")

  // Decoration
  lines.push("decoration {")
  lines.push(`    rounding = ${config.borderRadius}`)
  lines.push(`    active_opacity = ${config.activeOpacity}`)
  lines.push(`    inactive_opacity = ${config.inactiveOpacity}`)
  lines.push("")
  lines.push("    shadow {")
  lines.push(`        enabled = ${config.shadow}`)
  lines.push(`        range = ${config.shadowRange}`)
  lines.push(`        render_power = ${config.shadowRenderPower}`)
  lines.push("    }")
  lines.push("")
  lines.push("    blur {")
  lines.push(`        enabled = ${config.blurEnabled}`)
  lines.push(`        size = ${config.blurSize}`)
  lines.push(`        passes = ${config.blurPasses}`)
  lines.push("    }")
  lines.push("}")
  lines.push("")

  // Animations
  lines.push("animations {")
  lines.push(`    enabled = ${config.animationEnabled}`)
  if (config.animationEnabled) {
    lines.push("")
    lines.push("    bezier = smooth, 0.05, 0.9, 0.1, 1.05")
    lines.push("")
    const speed = (7 / config.animationSpeed).toFixed(0)
    lines.push(`    animation = windows, 1, ${speed}, smooth`)
    lines.push(`    animation = windowsOut, 1, ${speed}, smooth, popin 80%`)
    lines.push(`    animation = fade, 1, ${speed}, smooth`)
    lines.push(`    animation = workspaces, 1, ${(6 / config.animationSpeed).toFixed(0)}, smooth, slide`)
  }
  lines.push("}")
  lines.push("")

  // Dwindle / Master
  if (config.layout === "dwindle") {
    lines.push("dwindle {")
    lines.push("    pseudotile = true")
    lines.push("    preserve_split = true")
    lines.push("}")
  } else {
    lines.push("master {")
    lines.push("    new_status = master")
    lines.push("}")
  }
  lines.push("")

  // Misc
  lines.push("misc {")
  lines.push("    force_default_wallpaper = 0")
  lines.push("    disable_hyprland_logo = true")
  lines.push("}")
  lines.push("")

  // Window Rules
  if (config.windowRules.length > 0) {
    lines.push("# Window Rules")
    for (const rule of config.windowRules) {
      for (const r of rule.rules) {
        lines.push(`windowrulev2 = ${r}, ${rule.match}`)
      }
    }
    lines.push("")
  }

  // Keybinds
  lines.push("# Keybinds")
  for (const bind of config.keybinds) {
    const mods = bind.mods.join(" ")
    const args = bind.args ? `, ${bind.args}` : ""
    lines.push(`bind = ${mods}, ${bind.key}, ${bind.action}${args}`)
  }
  lines.push("")

  // Mouse binds
  lines.push("# Mouse binds")
  lines.push("bindm = SUPER, mouse:272, movewindow")
  lines.push("bindm = SUPER, mouse:273, resizewindow")

  return lines.join("\n")
}

type TokenType = "comment" | "section" | "key" | "value" | "keyword" | "text"

interface Token {
  type: TokenType
  text: string
}

function tokenizeLine(line: string): Token[] {
  const trimmed = line.trimStart()

  if (trimmed.startsWith("#")) {
    return [{ type: "comment", text: line }]
  }

  if (trimmed.endsWith("{")) {
    return [{ type: "section", text: line }]
  }

  if (trimmed === "}") {
    return [{ type: "section", text: line }]
  }

  if (trimmed.startsWith("bind")) {
    const eqIdx = line.indexOf("=")
    if (eqIdx !== -1) {
      return [
        { type: "keyword", text: line.slice(0, eqIdx + 1) },
        { type: "value", text: line.slice(eqIdx + 1) },
      ]
    }
    return [{ type: "keyword", text: line }]
  }

  if (trimmed.startsWith("monitor") || trimmed.startsWith("env") || trimmed.startsWith("exec") || trimmed.startsWith("windowrulev2")) {
    const eqIdx = line.indexOf("=")
    if (eqIdx !== -1) {
      return [
        { type: "keyword", text: line.slice(0, eqIdx + 1) },
        { type: "value", text: line.slice(eqIdx + 1) },
      ]
    }
    return [{ type: "keyword", text: line }]
  }

  const eqIdx = line.indexOf("=")
  if (eqIdx !== -1 && trimmed.length > 0) {
    return [
      { type: "key", text: line.slice(0, eqIdx + 1) },
      { type: "value", text: line.slice(eqIdx + 1) },
    ]
  }

  return [{ type: "text", text: line }]
}

const TOKEN_COLORS: Record<TokenType, string> = {
  comment: "text-muted-foreground/60",
  section: "text-accent font-medium",
  key: "text-foreground",
  value: "text-muted-foreground",
  keyword: "text-accent",
  text: "text-foreground",
}

export function ConfigPreview() {
  const { config } = useHyprconf()

  const confText = useMemo(() => generateHyprlandConf(config), [config])
  const lines = useMemo(() => confText.split("\n"), [confText])

  return (
    <div className="h-full w-full overflow-auto bg-[#0d0d0d] p-6 font-mono text-xs leading-relaxed">
      <div className="min-w-0">
        {lines.map((line, i) => {
          const tokens = tokenizeLine(line)
          return (
            <div key={i} className="flex">
              <span className="inline-block w-8 shrink-0 select-none text-right pr-4 text-muted-foreground/30">
                {i + 1}
              </span>
              <span className="whitespace-pre">
                {tokens.map((token, j) => (
                  <span key={j} className={TOKEN_COLORS[token.type]}>
                    {token.text}
                  </span>
                ))}
              </span>
            </div>
          )
        })}
      </div>
    </div>
  )
}
